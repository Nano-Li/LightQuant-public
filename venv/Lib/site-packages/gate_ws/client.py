# !/usr/bin/env python
# coding: utf-8
import abc
import asyncio
import hashlib
import hmac
import json
import logging
import ssl
import time

import typing
from typing import Union, Callable

import websockets
from websockets.exceptions import WebSocketException

logger = logging.getLogger(__name__)


class GateWebsocketChannelError(Exception):

    def __init__(self, code, message):
        self.code = code
        self.message = message

    def __str__(self):
        return 'code: %d, message: %s' % (self.code, self.message)


class GateWebsocketApiError(Exception):

    def __init__(self, label, message):
        self.label = label
        self.message = message

    def __str__(self):
        return 'label: %s, message: %s' % (self.label, self.message)


class Configuration(object):

    def __init__(self,
                 app: str = 'spot',
                 settle: str = 'usdt',
                 test_net: bool = False,
                 host: str = None,
                 api_key: str = '',
                 api_secret: str = '',
                 event_loop=None,
                 executor_pool=None,
                 default_callback=None,
                 ping_interval: int = 5,
                 max_retry: int = 10,
                 verify: bool = True):
        """Initialize running configuration

        @param app: Which websocket to connect to, spot or futures, default to spot
        @param settle: If app is futures, which settle currency to use, btc or usdt
        @param test_net: If app is futures, whether use test net
        @param host: Websocket host, inferred from app, settle and test_net if not provided
        @param api_key: APIv4 Key, must not be empty if subscribing to private channels
        @param api_secret: APIv4 Secret, must not be empty if subscribing to private channels
        @param event_loop: Event loop to use. default to asyncio default event loop
        @param executor_pool: Your callback executor pool. Default to asyncio default event loop if callback is
        awaitable, otherwise asyncio default concurrent.futures.Executor executor
        @param default_callback: Default callback function for all channels. If channels specific callback is not
        provided, it will be called instead
        @param ping_interval: Active ping interval to websocket server, default to 5 seconds
        @param max_retry: Connection retry times on connection to server lost. Reconnect will be given up if
        max_retry reached. No upper limit if negative. Default to 10.
        @param verify: enable certificate verification, default to True
        """
        self.app = app
        self.api_key = api_key
        self.api_secret = api_secret
        default_host = 'wss://api.gateio.ws/ws/v4/'
        if app == 'futures':
            default_host = 'wss://fx-ws.gateio.ws/v4/ws/%s' % settle
            if test_net:
                default_host = 'wss://fx-ws-testnet.gateio.ws/v4/ws/%s' % settle
        self.host = host or default_host
        self.loop = event_loop
        self.pool = executor_pool
        self.default_callback = default_callback
        self.ping_interval = ping_interval
        self.max_retry = max_retry
        self.verify = verify


class WebSocketRequest(object):
    """
    gate服务器通信websocket类，所有类型的请求(各个频道订阅)都通过该类发出
    该类聚合信息并整合为json数据，
    """

    def __init__(self, cfg: Configuration, channel: str, event: str, payload: Union[str | dict | list], require_auth: bool = False):
        self.channel = channel
        self.event = event
        self.payload = payload
        self.require_auth = require_auth
        self.cfg = cfg

    def __str__(self):
        request = {
            'time': int(time.time()),
            'time_ms': int(time.time() * 1000),
            'channel': self.channel,
            'event': self.event,
            'payload': self.payload,
        }
        if self.require_auth:
            if not (self.cfg.api_key and self.cfg.api_secret):
                raise ValueError("configuration does not provide api key or secret")
            message = "channel=%s&event=%s&time=%d" % (self.channel, self.event, request['time'])
            request['auth'] = {
                "method": "api_key",
                "KEY": self.cfg.api_key,
                "SIGN": hmac.new(self.cfg.api_secret.encode("utf8"), message.encode("utf8"),
                                 hashlib.sha512).hexdigest()
            }
        return json.dumps(request)


class WebSocketChannelRequest(WebSocketRequest):
    """
    新定义channel请求，用于区分
    """
    def __init__(self, cfg: Configuration, channel: str, event: str, payload: list, require_auth: bool = False):
        super().__init__(cfg, channel, event, payload, require_auth)


class WebSocketApiRequest(WebSocketRequest):

    def __init__(self, cfg: Configuration, channel: str, event: str, payload: dict, require_auth: bool = False):
        super().__init__(cfg, channel, event, payload, require_auth)


class WebSocketResponse(object):
    """
    解析所有服务器返回数据
    根据数据特征判断为订阅通道返回/下单返回/pong返回
    """

    # 由于使用了工厂函数，__init__方法不会调用
    def __init__(self, body: str):
        self.body = body
        self.msg = json.loads(body)
        # code not used
        self.channel = self.msg.get('channel')
        if not self.channel:
            raise ValueError("no channel found from response message: %s" % body)

        self.timestamp = self.msg.get('time')  # get None if no such key
        self.event = self.msg.get('event')
        self.result = self.msg.get('result')
        self.error = None
        if self.msg.get('error'):
            self.error = GateWebsocketChannelError(self.msg['error'].get('code'), self.msg['error'].get('message'))

    @classmethod
    def parse(cls, body: str):
        # 最耗时的一行代码，避免重复使用
        msg = json.loads(body)
        if 'header' in msg:
            return WebSocketApiResponse(msg)
        else:
            return WebSocketChannelResponse(msg)


class WebSocketChannelResponse(object):
    """
    包含通道返回和pong返回
    """
    # response_type = 'channel'

    def __init__(self, msg: dict):
        self.msg = msg
        self.channel = self.msg.get('channel')
        if not self.channel:
            raise ValueError(f"no channel found from response message: {self.msg}")

        self.timestamp = self.msg.get('time')
        self.event = self.msg.get('event')
        self.result = self.msg.get('result')
        self.error = None
        if self.msg.get('error'):
            self.error = GateWebsocketChannelError(self.msg['error'].get('code'), self.msg['error'].get('message'))


class WebSocketApiResponse(object):
    # response_type = 'api'

    def __init__(self, msg: dict):
        # get None if no such key
        self.request_id = msg.get('request_id')
        self.ack: bool = msg.get('ack')
        self.header: dict = msg.get('header')
        self.data: dict = msg.get('data')

        self.channel = self.header['channel']

        self.error = None
        if self.data.get('errs'):
            self.error = GateWebsocketApiError(self.data['errs'].get('label'), self.data['errs'].get('message'))

        self.result = self.data.get('result')
        # todo: modify here


class Connection(object):
    """
    Gate异步连接类
    新功能兼容异步加单接口
    todo: 1. sending history 修改
          2. (re) login方法，及失败处理（callback自行处理）
          3. websocket response 增添下单返回解析 done
          4. 高速处理每一个下单返回
    """

    def __init__(self, cfg: Configuration, enable_ping: bool = True):
        self.cfg = cfg
        self.channels: typing.Dict[str, typing.Any] = dict()  # 用于存储所有通道的回调函数, {'futures.usertrades': function_name, }
        self.api_callback = None  # 用于定义下单的回调函数
        self.sending_queue = asyncio.Queue()
        self.sending_history = list()
        # self.current_subscription: dict[str,list[list]] = dict()        # 用于存储所有当前订阅, {'futures.usertrades': [["20011", "BTC_USDT"], ], }, abandon
        self.event_loop: asyncio.AbstractEventLoop = cfg.loop or asyncio.get_event_loop()
        self.main_loop = None

        self.enable_ping: bool = enable_ping
        self.login_id = 'open_sesame✫'

    def register(self, channel, callback: Callable = None):
        # define channel callbacks
        if callback:
            self.channels[channel] = callback

    def unregister(self, channel):
        self.channels.pop(channel, None)

    def order_callback(self, callback: Callable):
        self.api_callback = callback

    def recover_subscription(self):
        # 根据保存的通道订阅信息，恢复订阅状态
        pass

    @staticmethod
    def packing_message(channel, req_param, time_now):
        message = "%s\n%s\n%s\n%d" % ("api", channel, req_param, time_now)
        return message

    def login(self) -> None:
        channel_login = "futures.login"
        req_param = ""
        time_now = int(time.time())

        login_payload = {
            "api_key": self.cfg.api_key,
            "signature": hmac.new(self.cfg.api_secret.encode("utf8"), self.packing_message(channel=channel_login, req_param=req_param, time_now=time_now).encode("utf8"),
                                  hashlib.sha512).hexdigest(),
            "timestamp": "%d" % time_now,
            "req_id": self.login_id
        }

        self.send_msg(WebSocketApiRequest(
            cfg=self.cfg,
            channel=channel_login,
            event='api',
            payload=login_payload,
        ))

    def send_msg(self, msg):
        self.sending_queue.put_nowait(msg)

    async def _active_ping(self, conn: websockets.WebSocketClientProtocol):
        # todo: temp debug fun, simulate disconnect every 60s
        n = 1
        while True:
            data = json.dumps({'time': int(time.time()), 'channel': '%s.ping' % self.cfg.app})
            # data = json.dumps({'time_ms_client': int(1000 * time.time()), 'channel': '%s.ping' % self.cfg.app})
            # print('\n给服务器发ping:\n', data, '\n', type(data))
            await conn.send(data)
            await asyncio.sleep(self.cfg.ping_interval)

            # if n >= 6:
            #     print('test disconnect')
            #     raise websockets.ConnectionClosed(1000, "normal closure")
            # n += 1

    async def _write(self, conn: websockets.WebSocketClientProtocol):
        if self.sending_history:
            for msg in self.sending_history:
                if isinstance(msg, WebSocketRequest):
                    msg = str(msg)
                # print('\n从历史中给服务器发信:\n', msg, type(msg))
                await conn.send(msg)
        while True:
            msg = await self.sending_queue.get()
            # 这行代码可以用于保证重新连接成功后，将发送过的通道连接请求再发送一遍，这样可以恢复原来的通道连接状态
            if isinstance(msg, WebSocketChannelRequest):
                self.sending_history.append(msg)
                msg = str(msg)
            elif isinstance(msg, WebSocketApiRequest):
                # do not save order request to history
                msg = str(msg)
            elif isinstance(msg, WebSocketRequest):
                raise TypeError('invalid instance created! plz check code')
            else:
                pass
            # self.sending_history.append(msg)
            # if isinstance(msg, WebSocketRequest):
            #     msg = str(msg)
            # print('\n给服务器发信:\n', msg, '\n', type(msg))
            # print('\n给服务器发信:', msg)
            await conn.send(msg)

    async def _read(self, conn: websockets.WebSocketClientProtocol):
        """
        解析返回信息，读取通道信息，并执行对应的回调函数
        :param conn:
        :return:
        """
        # todo: 对于通道和下单返回，可能使用不同的处理方式
        async for msg in conn:
            # print('\n收到服务器信息: \n', msg, '\n', type(msg))
            # print('\n收到服务器信息: ', msg)
            response = WebSocketResponse.parse(msg)
            # callback = self.channels.get(response.channel, self.cfg.default_callback)
            if isinstance(response, WebSocketChannelResponse):
                callback = self.channels.get(response.channel, self.cfg.default_callback)
            elif isinstance(response, WebSocketApiResponse):
                callback = self.api_callback
            else:
                callback = self.cfg.default_callback

            if callback is not None:
                if asyncio.iscoroutinefunction(callback):
                    # todo: 注意这里是使用创建协程方法而不是await方法执行回调函数，测试交易系统，如果没问题就不修改
                    self.event_loop.create_task(callback(self, response))
                else:
                    self.event_loop.run_in_executor(self.cfg.pool, callback, self, response)
            else:
                # pong 返回就不需要callback
                pass

    def close(self):
        if self.main_loop:
            self.main_loop.cancel()

    async def run(self):
        stopped = False
        retried = 0
        while not stopped:
            try:
                ctx = None
                if self.cfg.host.startswith('wss://'):
                    ctx = ssl.create_default_context()
                    if not self.cfg.verify:
                        ctx.check_hostname = False
                        ctx.verify_mode = ssl.CERT_NONE

                # compression is not fully supported in server
                conn = await websockets.connect(self.cfg.host, ssl=ctx, compression=None)
                if retried > 0:
                    logger.warning("reconnect succeeded after retrying %d times", retried)
                    retried = 0
                    print('\n\nrun retry login')
                    self.login()  # auto re login after disconnection; todo: login位置需要考虑
            # DNS might be resolved to multiple address, which cause multiple ConnectionRefusedError
            # being combined to one OSError
            except (WebSocketException, ConnectionRefusedError, OSError) as e:
                logger.warning("failed to connect to server for the %d time, try again later: %s", retried + 1, e)
                if 0 < self.cfg.max_retry <= retried:
                    logger.error("max reconnect time %d reached, give it up", self.cfg.max_retry)
                    stopped = True
                    continue
                await asyncio.sleep(0.5 * retried)
            else:
                tasks: typing.List[asyncio.Task] = list()
                try:
                    tasks.append(self.event_loop.create_task(self._write(conn)))
                    tasks.append(self.event_loop.create_task(self._read(conn)))
                    if self.enable_ping:
                        tasks.append(self.event_loop.create_task(self._active_ping(conn)))
                    self.main_loop = asyncio.gather(*tasks)
                    await self.main_loop
                except websockets.ConnectionClosed:
                    logger.warning("websocket connection lost, retry to reconnect")
                    retried += 1
                except asyncio.CancelledError:
                    await conn.close()
                    stopped = True
                finally:
                    # user callback tasks are not our concern
                    for task in tasks:
                        task.cancel()


class BaseChannel(abc.ABC):
    """
    所有通道的基类，其中name表示发信的具体channel
    """
    name = ''
    require_auth = False

    def __init__(self, conn: Connection, callback: Callable = None):
        self.conn = conn
        self.callback = callback
        self.cfg = self.conn.cfg
        self.conn.register(self.name, callback)

    def subscribe(self, payload: list = None):
        self.conn.send_msg(WebSocketChannelRequest(
            cfg=self.cfg,
            channel=self.name,
            event='subscribe',
            payload=payload,
            require_auth=self.require_auth
        ))

    def unsubscribe(self, payload: list = None):
        self.conn.send_msg(WebSocketChannelRequest(
            cfg=self.cfg,
            channel=self.name,
            event='unsubscribe',
            payload=payload,
            require_auth=self.require_auth
        ))

    def __del__(self):
        # 当实例被删除时，
        print('\n{} channel 实例被删除!!!'.format(self.name))
        self.conn.unregister(self.name)

