# -*- coding: utf-8 -*-
# @Time : 2024/1/27 9:31
# @Author : 
# @File : api.py 
# @Software: PyCharm
import asyncio
import hashlib
import hmac
import logging
import time

from typing import Callable

from gate_api import FuturesOrder, FuturesOrderAmendment
from gate_ws.client import Connection, WebSocketApiRequest, WebSocketApiResponse, GateWebsocketApiError

logger = logging.getLogger(__name__)


class AsyncOrderClient(object):
    """
    异步下单客户端，封装下单功能
    """
    event = 'api'

    # require_auth = False

    def __init__(self, conn: Connection, callback: Callable = None):
        self.conn = conn
        if not asyncio.iscoroutinefunction(callback):
            raise TypeError('need a coroutine callback function')
        self.callback = callback
        self.cfg = self.conn.cfg
        self.conn.order_callback(self.dealing_api_response)          # define callback of order response

        self.req_count = 0                          # used as default req id
        self.login_id = self.conn.login_id
        # 异步客户端的核心功能，根据唯一请求id，处理已发送的信息
        self._info_cache: dict = {}
        # self._info_cache: dict = {self.login_id: 'initial_login'}

    @staticmethod
    def packing_message(channel, req_param, time_now):
        message = "%s\n%s\n%s\n%d" % ("api", channel, req_param, time_now)
        return message

    def login(self, key: str, secret: str) -> None:
        channel_login = "futures.login"
        req_param = ""
        time_now = int(time.time())

        login_payload = {
            "api_key": key,
            "signature": hmac.new(secret.encode("utf8"), self.packing_message(channel=channel_login, req_param=req_param, time_now=time_now).encode("utf8"),
                                  hashlib.sha512).hexdigest(),
            "timestamp": "%d" % time_now,
            "req_id": self.login_id
        }
        self._add_cache(self.login_id, 'longin')
        self.conn.send_msg(WebSocketApiRequest(
            cfg=self.cfg,
            channel=channel_login,
            event=self.event,
            payload=login_payload,
        ))

    async def dealing_api_response(self, conn: Connection, response: WebSocketApiResponse) -> None:
        """
        websocket api下单的回调函数
        处理并返回所有的订单下单信息：下单成功，失败及原因
        操作：根据请求websocket请求id逐个处理
        # todo: 先使用自己便利的形式，后续可以改为官方样式，算法有优化空间
        :return: 订单请求情况,dict
        """
        if response.request_id in self._info_cache:
            ack_status: dict = {
                'channel': response.channel,
                'success': False,
                'result': '',
                'error': ''
            }

            # todo 考虑不同的通道分开寄存，而不是统一判断，以提高效率
            if response.channel == 'futures.order_place':
                if response.ack:
                    # 不处理成功回声
                    return
                if response.error:
                    # ack_status['success'] = False
                    ack_status['error'] = response.error
                    save_order: FuturesOrder = self._info_cache[response.request_id]
                    ack_status['result'] = {
                        'contract': save_order.contract,
                        'size': save_order.size,
                        'price': save_order.price,
                        'tif': save_order.tif,
                        'text': save_order.text
                    }
                    await self.callback(ack_status)
                elif response.result:
                    ack_status['success'] = True
                    ack_status['result'] = response.result
                    await self.callback(ack_status)
                else:
                    raise KeyError('no info from response data')
                self._info_cache.pop(response.request_id)

            elif response.channel == 'futures.order_batch_place':
                if response.ack:
                    return
                if response.error:
                    for _e in self._info_cache[response.request_id]:
                        single_ack_status = ack_status.copy()
                        single_ack_status['error'] = response.error
                        await self.callback(single_ack_status)
                    self._info_cache.pop(response.request_id)
                    return

                for _i, each_order_result in enumerate(response.result):
                    single_ack_status = ack_status.copy()
                    if each_order_result.get('succeeded'):
                        single_ack_status['success'] = True
                        single_ack_status['result'] = each_order_result
                        await self.callback(single_ack_status)
                    else:
                        single_ack_status['error'] = GateWebsocketApiError(each_order_result['label'], each_order_result['detail'])
                        # 返回的只有错误信息，从存储中提取订单信息
                        save_order: FuturesOrder = self._info_cache[response.request_id][_i]
                        single_ack_status['result'] = {
                            'contract': save_order.contract,
                            'size': save_order.size,
                            'price': save_order.price,
                            'tif': save_order.tif,
                            'text': save_order.text
                        }
                        await self.callback(single_ack_status)
                self._info_cache.pop(response.request_id)

            elif response.channel == 'futures.order_cancel':
                if response.error:
                    ack_status['error'] = response.error
                    ack_status['result'] = {'text': self._info_cache[response.request_id]}
                elif response.result:
                    ack_status['success'] = True
                    ack_status['result'] = response.result
                else:
                    raise KeyError('no info from response data')
                await self.callback(ack_status)
                self._info_cache.pop(response.request_id)
            elif response.channel == 'futures.order_amend':
                # 即使订单信息相同，也会返回成功的修改信息
                if response.error:
                    ack_status['error'] = response.error
                    ack_status['result'] = {'text': self._info_cache[response.request_id]}
                elif response.result:
                    ack_status['success'] = True
                    ack_status['result'] = response.result
                else:
                    raise KeyError('no info from response data')
                await self.callback(ack_status)
                self._info_cache.pop(response.request_id)
            elif response.channel == 'futures.order_list':
                pass
            elif response.channel == 'futures.order_status':
                pass
            elif response.channel == 'futures.login':
                if response.error:
                    ack_status['error'] = response.error
                elif response.result:
                    ack_status['success'] = True
                    ack_status['result'] = response.result
                else:
                    raise KeyError('no info from response data')
                await self.callback(ack_status)
                self._info_cache.pop(response.request_id)
            elif response.channel == 'futures.order_cancel_cp':
                pass
            else:
                print(f'undefined channel: {response.channel}')
        else:
            if response.request_id == self.login_id:
                print('unregistered login')
            else:
                raise KeyError(f'received unknown request id: {response.request_id}!')
                # logger.warning('received unknown request id: {response.request_id}!')

    def create_order(self, order_info: FuturesOrder):
        if not isinstance(order_info, FuturesOrder):
            raise TypeError('input argument err')
        req_id = self.gen_req_id()
        req_payload = {
            "req_id": req_id,
            "req_param": {
                "contract": order_info.contract,
                "size": order_info.size,
                "price": order_info.price,
                "tif": order_info.tif,
                "text": order_info.text
            },
        }
        # 增加平仓判断
        if order_info.close:
            req_payload['req_param']['close'] = order_info.close
        self._add_cache(req_id, order_info)
        self.conn.send_msg(WebSocketApiRequest(
            cfg=self.cfg,
            channel='futures.order_place',
            event=self.event,
            payload=req_payload,
        ))

    def create_batch_order(self, orders_info: list[FuturesOrder]):
        # if len(orders_info) == 0:
        #     raise TypeError('empty list received')
        req_id = self.gen_req_id()
        batch_payload = {
            "req_id": req_id,
            "req_param": [
                {
                    "contract": each.contract,
                    "size": each.size,
                    "price": each.price,
                    "tif": each.tif,
                    "text": each.text
                } for each in orders_info
            ]
        }
        self._add_cache(req_id, orders_info)
        self.conn.send_msg(WebSocketApiRequest(
            cfg=self.cfg,
            channel='futures.order_batch_place',
            event=self.event,
            payload=batch_payload
        ))

    def cancel_order(self, user_order_id: str):
        req_id = self.gen_req_id()
        cancel_payload = {
            "req_id": req_id,
            "req_param": {
                "order_id": user_order_id
            }
        }
        self._add_cache(req_id, user_order_id)
        self.conn.send_msg(WebSocketApiRequest(
            cfg=self.cfg,
            channel='futures.order_cancel',
            event=self.event,
            payload=cancel_payload
        ))

    def amend_order(self, order_id: str, amend_info: FuturesOrderAmendment):
        if not isinstance(amend_info, FuturesOrderAmendment):
            raise TypeError('input argument err')
        if (amend_info.size is None) == (amend_info.price is None):
            raise ValueError('redundant amend arg received')

        req_id = self.gen_req_id()
        amend_payload = {
            "req_id": req_id,
            "req_param": {
                "order_id": order_id,
            }
        }
        if amend_info.size is not None:
            amend_payload['req_param']['size'] = amend_info.size
        elif amend_info.price is not None:
            amend_payload['req_param']['price'] = amend_info.price
        self._add_cache(req_id, order_id)
        self.conn.send_msg(WebSocketApiRequest(
            cfg=self.cfg,
            channel='futures.order_amend',
            event=self.event,
            payload=amend_payload
        ))

    def _add_cache(self, req_id: str, req_info) -> None:
        """
        将订单请求id与请求信息构建一一映射
        :param req_id:
        :param req_info:
        :return:
        """
        self._info_cache[req_id] = req_info

    def gen_req_id(self) -> str:
        """
        高速高效产生唯一标识符     # todo : time consume test
        :return:
        """
        if self.req_count >= 9999999999:
            self.req_count = 1
        else:
            self.req_count += 1

        return str(self.req_count).zfill(12)

